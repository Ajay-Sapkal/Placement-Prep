Hey guys, welcome back to the channel. This is Riti Duta and I'm back with another video on Java tutorials. So if you haven't checked out my road map videos on Java backend development that how can you get started with Java backend development and what are the things you need to learn, you can definitely go and check out the video on my channel. Also don't forget to check out my video on code Java where I tell you that what are the things that you need to learn in the Java programming language. Apart from that I have made a extensive 3-hour long video on collections and this video on multi-threading is going to be very very similar. So in this video I'm going to cover all the important topics of multi-threading right from the very scratch. So if you don't know a single thing about multi- threading this video is definitely for you. You don't need to watch this entire video at one go. Watch it at your own pace. These topics and concepts are obviously there out on internet but they are very scattered and I felt that okay let me bring all of this let me compile all of this in a very simpler fashion and bring it down to one video so that it would be very helpful for you guys to prepare. Right without any further guys now let's get started with multi- threading. I know it's a very intimidating topic for a lot of freshers out there but trust me I will try to make it very very easy for you. So now let's get started with multi- threading in Java. So before starting off with multi- threading in Java we have to understand this very thing that multi-threading is not a concept of Java right. So what is multi-threading right? So before starting off with multi-threading let's learn what is multitasking like what do you mean basically by multitasking. So if you just go with the English meaning of this word, it means that you are doing multiple tasks simultaneously or you are doing multiple tasks at the same time. Right? Now imagine this in terms of computers. So when we say that a computer is multitasking. So that means that a computer is running programs parallelly, right? It is running multiple programs parallely. So for example, humans do tasks, right? Human do tasks or work parallelly, right? For example, so maybe I can wake up in the morning, right? and maybe I can you know brush my teeth and while brushing my teeth I may be listening to some music right so there are two tasks that are happening paralle so I'm also kind of multitasking but when it comes to computers it's all about running different programs simultaneously right so there are two types of multitasking that exist in computer terms right one is process based multitasking and another is thread based multitasking now let's take a very easy example okay so let's say you are uh typing some document in MSW right and at the same time you painting something on image paint right and you're context switching between these two programs I know context switching might be a very heavy word but let's say just switching between the two programs right so now what is happening is you're running two programs in parallel and that is quite common right you might be watching a movie on VC media player at the same time you might be you know on Google chrome surfing right so this is this is very common right so we are all accustomed to you know using programs and computer simultaneously that is basically what we call a process-based multitasking where we are running mult multiple programs at the same time. Right? Now comes our second topic that is thread based multitasking. Now thread based multitasking is very similar to process based multitasking. So here we are running two programs parallely. But thread is is all about running two threads parallely. But what does it mean? Right? So it means again let's come back to that very example of us using MSWord. Right? So now let's say in MS word we are typing something and at the same time we our autocorrect shows us that hey uh this this word is the spelling of this word is not right okay or maybe the formatting is not right. So what is happening ideally over here whenever we are typing something so that one task that particular uh MS word program is doing is printing whatever you're typing on the screen right and at the same time there is another sort of function that is running uh which you know implements the autocorrect function right so to the user it might seem that everything is happening on the go but actually it is not and you will see that later in action but what I can say is that is where the thread based multitasking comes into picture so whenever you want to do multitasking within a particular program itself, right? Within a particular program itself, then thread based multitasking comes into picture, right? So multiple threads run within a program. So if there are multiple programs or multiple process running paraly that is process based multitasking, right? But when when now when it comes to the context of one single program and within that program there are multiple features or multiple functions happening, right? Then thread based multitasking comes to the four. Okay. So here within the same program you're doing multitasking and that's where thread comes into the picture. So now it brings us to the next question that tell me the difference between a thread and a process and I'm very sure by the time you must be already knowing what the difference is. Uh and this is a very very important question that you would definitely get asked in any of your interviews in your placements be it for service based companies or in product based companies. So again let's see what are the differences. So since since multiple threads work for a same program right as I said the threads the context is within a particular program. So let's say if there is MSW word within MSWord there will be multiple threads running parallelly or simultaneously to you know do the do different functions or implement different functions right and that is why two threads share the same address space right also since they share the same address space switching switching between two threads is fairly less expensive than switching between two process right because they don't exist in same address space or so basically when you want to switch between MSWord to MS paint that is kind of an expensive operation for the CPU but when you're trying to you know switch between multiple threads within the same particular program that is less expensive as I said because the two threads share the same address space and obviously the cost of communication between threads is also low the two threads want to communicate with each other that is also pretty low as compared to communication between process because again of the same entry space so that's the difference between fair and process okay Now let's understand it why do we need multi-threading? Okay. So now let's take a very simple example of our human behavior right we human behavior are actually multitaskers right now let me tell you a very uh fun example of a multitasking let's say that like we are developers right and when we are working for big companies with a very large codebase when we are building our project right that build of a code right takes a long time right so some in some code base if you want to build that code base it usually takes around let's say 30 minutes it might take up to even an hour at times So what do we developers do at that time right? Do we just sit back and watch the build happen and wait for it? No, we do some other task at that time like let's say we read a book or we read some documentation or maybe we jump into some meetings or at worst we watch Instagram res right that's what we do so so basically that is multitasking right so we don't wait for one particular task to complete because if you are doing that then can you understand that if you're waiting for a particular task that I know will take a lot of time to complete and if I wait for it to complete first and then I start the next work which is in no way dependent on my next last task right So now let's say if I have to read a documentation which is in now way involved with the build of the code that I'm doing right I know that I can do these things parallely. So I can just put this on build right I can put the code on build and I can read the documentation parally right now let's take another example right. So let's say you wake up on a cold winry morning and you want to take a bath and for that you have to switch on the gizar right and the gizar let's say will take 10 minutes okay uh to boil the water so that you can take a bath. So what would you idally do in those 10 minutes right because you might if you leaving for office you might want to pack your bags or you might want to you know read a newspaper within that 10 minutes or will you wait like try to think on in terms of a human like what would you what would you do would you wait for the gizar to first boil the water you will wait for 10 minutes you would sle absolutely do nothing take a bath and then you will start reading the newspaper to do other things like packing the bag or whatever it right you will use that 10 minutes of idle time that you have nothing to do where the gizar is doing his job and you would use that 10 minutes to do something else. Right? So that so now you can understand that how multitasking is an integral part of our day-to-day lives. Whenever there is we are waiting for something or some events to occur which is really not dependent on us right most of the time we try to delegate the idle time by doing something else right similarly for computers as well there are lot of events that happens when the CPU is just sitting idle it is just waiting for some operation to happen. So when that when the CPU is waiting for the user input and the user is delaying to give their input or whatever reason where the CPU can use that time the CPU can use that time to do other task right and that is where the multi-threading concept of multi-threading comes into picture. So now what it is saying is in a single thread environment only one task at a time can be performed. So there's a sequential execution of task that happens. I mean uh that's what we have seen like that's what we used to seeing when we are running computer programming right there's this main function and it just executes sequentially and it ends till uh once uh it completes right once the main method stops executing in Java the that's the that's it right so if you do that in a single environment only one task as I said can be performed and CPU cycles are wasted for example when we're waiting for user input right that's what I said so multitasking allows ideal CPU time to put to be put into use to solve other problems or do other tasks right so when the CPU is waiting for some user input it might do par some other task or imple or maybe it can implement some other functions right so that's where the multi- threading concept comes in now let's look at the thread class in Java so now let's look at what is a thread right so thread is basically an independent sequential path of execution within a program so basically a main is also a thread right uh so when we are running our Java program in a single thread environment like when I say single thread environment consider like the programs all the programs that you we were running so far right all those programs are single threaded And why I say single threaded because Java has this uh thread called which it calls the main thread which we are going to dive deep just after this right. Uh and when the main thread stops executing right then the program flow stops or the program stops right. So similarly if you want like to create other threads like the main thread we don't have to explicitly create but that is being automatically created but if you want to create more threads on top of the main thread then that is something where we delve into the world of multi-threading in Java and that's what we are actually going to learn in this video and over there as well it is it is nothing different right even in main you are running a sequential set of instructions if you create a different thread there also you would be running a sequential instead of instructions but it those those two instructions will be in par right not exactly parody we'll see how it is working but you can consider for now that those instructions are going to like follow an independent path of execution independent flow right so many threads can run concurrently within a program at runtime threads in a program exist in a common memory space right that's very evident and therefore share both data and code so if you if you like have multiple threads they would have access to the same code as well as the same data and they also share the process running the program okay now let's look at the three important concepts that we are going to cover in this video mostly related to multi-threading in Java. So one is that creating threads and providing the code that is getting executed by the thread right. So how do we create a thread apart from the main threads like how can we create our own custom threads right and uh like like how do we provide the code that the thread should ideally run right then the next part is accessing common data and code to synchronization right and how do we transition between thread states I know a couple of these things might be sounding a little bit intimidating to you but don't worry we are going to dive deep into it and once I get started with these things these things will be very easy for you uh I'm just telling you all these things so that to at least know what's coming. Right? So these are the three things we're primary going to focus on. And now let's start with the very first important topic that is the main thread. Right? So now let's look at the very important concept that is the main thread. Right? So as I told you that whenever we are running any single threaded program or by single threaded I mean that the programs that we were running so far there is this main thread that is automatically being created right. So now if we have to create any thread right or we have to create our own custom thread so that we kind of uh leverage the multi-threading uh environment in Java right then we have to create our own thread and those threads how how are we going to create that I'm going to show you very soon but those would be spawned out from the main thread itself right I mean you have to create a thread programmatically you have to do it from the uh main thread right so that is why it's saying that all other threads called child threads are spawned from the main thread itself right now let's say the main method completes the set of execution but the program will still continue running if the other threads have not finished or the custom threads have not finished running the task. Right? Now there are two more important concepts here. One is the user thread and demon thread. So now let's see the difference basic difference between user thread and the demon thread. Right? So when there is no user threads running right again when there is no user threads running and all the user threads have finished executing their task that was being assigned to them. Okay, then the program will stop irrespective of whether the demon threads that were there or been were being created are still executing or not. Right? So there's a preference given to user threads, right? So if there is no user thread running and main is also user thread by the way. Okay? So if there is no user thread running, the program will stop irrespective of whether demon threads are running or not. Okay. So now let's say if main is a user thread okay and there are two more user threads that we created from the main thread and one we created one demon thread okay uh so there are four threads right now so let's say the main stops executing right but the two other user threads and one demon thread is still running the program will still not stop executing because because there are still two threads that are still running right now when these two user threads also stop executing like they have finished this task but the demon thread is still running the program will not look at the demon thread it will see okay all the three user threads are done and dusted with the task let's finish the program let's terminate the program a program only cares whether it has any user thread running or not so that's why it says that as long as a user thread is alive the JVM doesn't terminate a demon thread is basically at the mercy of the runtime system it is stopped if there are no more user threads running thus terminating the program right so it does not it does not have any preference as such and how can we create a demon thread so basically uh it is basic very similar to creating a thread right which we are going to see very soon so thread There's a method called set demon. So thread dot set demon if you pass true that means that now the thread is a demon thread and that should be done before we start the thread. Okay. So now let's understand that how can we create our own custom threads apart from the main thread. Right. So this can be done in two ways right. One is like implementing the java.langr runnable interface and another is create extending the thread class. So let's just quickly do that and get our hands dirty by you know uh creating our own user threads and running it and having some fun with it and then we will see what are some of the methods that exist and like why there are two ways right of creating threads and which one should you use. So we will see all of these things right. Okay. So there are two ways of creating a user thread right. Uh obviously this this function this uh main function is already executing within a main thread as I told but in if you want to create your own thread right or custom thread then there are two ways of doing it. So for the first way let's create a class right that is let's say thread one okay and let's extend the thread class right and extends okay so now let's override the run method public void run okay so this thread class has a run method Right? And we are overriding the run method. For now, let's understand this. Okay? And here the code piece of code that I would be writing. Okay? That piece of code would be executed uh for that particular thread. For example, whatever piece of code we want to execute for the main thread, we write it under void uh like public static void main, right? Similarly, whatever code we want to execute in this particular thread, we would write it under uh the run method. Okay? So let's run a fall do I Z I less than five and I ++ and simply print uh inside thread one okay and we will print the value of I that's it very simple thing that I'm doing so now back in the thread tester class what I would do is I would create a thread that is thread one equals to I will instantiate it with the object of thread one class and what I would do is I will call thread one dot start. So what the start method does is it doesn't start the thread immediately. It is an asynchronous method and it returns immediately. Right? Now what is what does like we don't know when the program starts. It is like up to the mercy of the JVM. So it basically the start method tells the JVM hey JVM like the user wants this thread to start. Now like whenever you feel free just start this thread. Okay. And when the JVM will feel that okay this is the time to run the thread. What it would do is it would call the run method that we just implemented inside this thread one class. That's it. Okay. So now let's also uh print that no main is exiting and just to give you some of like an idea and here like let's also print main is starting. Okay. Because here now since we are spawning off a thread from the main thread there are two threads that would be running right one is the main thread itself and other is the thread one that we just spawned off from the main thread that is this thread one. Okay. One more important concept is let's say from the main thread we created our own user thread right so therefore this thread one is is the child thread of the main thread because it is this particular thread one was spawned from main thread right now let's say inside this run function of thread one if you come to here if you would have uh spawned another thread like if you would have created another thread inside this run function you would have started it from here then thread one would have been the parent of the thread that started from this run. So basically we can understand that like from the thread from which we start another thread there is this parent child relationship between the two threads right so in this case uh it's main because we are spawning this thread off from main okay cool now let's run this program okay so now you see that main is starting and main is ex exiting and then this thread got executed so basically there is not no order uh that is being followed so if you run the same program you might get an order like this that main is starting then inside thread one inside thread one inside thread one then main is exiting and then the rest of the inside thread one code right so this is basically what happens so there is no order it is up to the mercy of the JVM in which order it should execute the code right and also you should not be making any assumptions about the order in which your code is getting executed because it is very much platform dependent so it can be of any order right so should not make any assumptions in which order the program should run right now one more thing if you can see the main it says that main is exiting from here right so the main thread got finished after this but still then the program didn't terminate and it allowed the other thread to run. This was because this was a user thread. This thread one was a user thread. Okay. Uh as I told you that whenever like the JVM sees that hey the main thread which is also user thread that has stopped right. But are there any other user threads that is running? Yes. Then the program continues. But if there is no user thread running, okay, if there is no user thread running, then it is up to the mercy of the JVM to either run the demon thread or let the demon thread continue its job or finish its job or it might have the option to end that demon thread abruptly. So you have to understand this particular thing very well that a program will only run if there is no user threads running. Right? If even if there are couple of demon threads running but no user threads running the program might terminate. Okay. So that is something you have to keep in mind. So only create a demon thread whenever you feel that demon thread has basically has no functionality of its own but it lives to serve the user thread. Right? So when the user thread dies demon thread has no existence or no significance. So that's is something you should keep in mind and therefore for that reason uh inside the thread class right uh there's a flag right? I will show you to you. Uh so if I go here and uh you will see that there's a there's a this is boolean field uh which is initially set to false and if you have to set it to true what you have to do is before starting off before starting off the thread you have to call thread one dot set demon and you have to explicitly mark it as true. Okay. So whenever you're marking it as true then you're explicitly telling that okay so now what happens once once we do this right now there is one user thread that is the main thread because main thread is always a user thread and now you have created another thread but this custom thread is not user thread it is a demon thread that means if the main executes stops executing right it might happen that this this entire thread one this entire thread one might not continue printing all the five values. So that's what it is right. So again summing it up if if JVM finds that there is no user thread running okay then the pro it it might not allow the demon thread to continue its job right but if there is any one user thread is running the program will not terminate even that if it means that the main thread has finished executing if there are other user threads that are running the program will still continue to run till all user threads finishes it jobs please remember that so now one more thing over here let's say you want to give this thread some name right so there is an overloaded constructor where you can also pass the name or give this thread some name so in this case we will call it thread one as well so basically for that also inside this thread one class we have to overload the constructor so we have to do a constructor overloading where we would basically say public thread one we'll get the thread name and we will call the super method of the super method will basically call the constructor of this thread class where we will pass the thread name and the thread name will be set. Okay. Now if you want to print if you want to print instead of doing this if you want to print the name of the thread what we will do is there is a static method in thread that mean the thread class itself thread dot get current thread or current thread that basically returns you the instance of the thread object that is currently running. So for instance uh let's say that like when this run method is getting executed that means this JVM is currently executing this particular thread right so if I do thread doc current thread this particular thread would be implemented right because right now the run function is running so the run function is getting executed so if if you're printing this that means you're inside the run function right that means the run function is getting executed of this particular thread so if you do thread dot current thread you will get the current thread right so you can just do get dot get name. So if you just print this, you will see that inside thread one, I mean I I forgot to add space, but you got the point, right? So now if you want to print the whole thread, what you would do is instead of doing the got debt name, uh let me add a space for this time and let's see. Okay, so let's run this code. You'll see what it does is it prints this thread name, right? It's parent parent of this thread is main and this is a thread parity which we will see later. Right. Okay. Cool. So that is one static method we found. Okay. We also seen the set demon. Okay. So now let's look at the second way. Well, we will create a thread implementing the runnable interface. So now let's create another class that is thread 2 and this will implement the runnable interface. Now this runnable interface will give me an error because I have to add I have to override this run function. Now let's quickly look what this runnable interface is. It's nothing. It's a function interface because it has one abstract method that is run. If there is any class that implements this runnable interface, it has to implement this abstract method run. It has to give some meaning to this run method. Right? So as a result, if a class is implementing the runnable interface, we have to give some implementation to this run method. So here we will also do the same thing. So what we will do is we will just uh like uh run this code in a hot loop and we will just write thread dot current thread uh plus we'll give a space and we'll print the value of I right okay cool so we implemented this and now how would we start this thread or how would we create this thread so this thread class right has another method right or another constructor where you can pass a an object of this runnable interface which is our thread 2. So new thread 2. Okay, cool. And then we can pass a thread name as well. That is optional. If you want, you can pass a thread name. If you don't want, you can omit this. Right? So that is optional. Uh so let's say if I don't want this, uh that won't give me an error because there is a constructor which just takes an object of the runnable interface. Or else if you want, then I can also give the name, right? Cool. And similarly once we have this thread so let's call this thread two we will just call thread two dot start and the start method will work the same so basically it will tell the JVM hey like uh the user is telling that you can start this thread now it is up to your mercy when you want to start it and this start calls immediately returns in case in case the thread has already started and again we want to do a thread 2 start then it will return an exception right saying that the thread has already started right and what happens is it's an uh it will return and what it will do is uh the JVM when it will try to schedule a thread. It might happen that the thread is not immediately scheduled to run. Okay. Uh we'll see other thread life cycles and that then it will get appeared to you. But for now what you can consider is whenever I'm calling the start method the thread might not get immediately get a chance to run. So uh the JVM whenever it feels that okay now is the time to run the thread or let give the thread some execution time in the CPU then it will call the run method that we implemented right and then it will get executed. Okay, cool. So now let's uh execute uh run this code. So now right now there are three user threads. One is the main thread and two user threads that we created. One thread user thread our custom thread we created using the uh extending the thread class and overriding the run method. And the second thing we did was we created an object of the runnable interface that is thread 2. We pass that object we pass this instance of the runnable interface uh to this set class. Right? And then we are doing the same thing by calling the start method. So you can see that uh main is starting then this this thread got executed and then when exited and then another thread got executed. Cool. Again this order could have been interle as well. Uh so I mean don't try to find any patterns in these orders, right? Because you know it is up to the mercy of the JVM that how do they want the threads to get executed. Okay. So now we saw that in two ways we can create thread. One is obviously by creating an instance of the runnable interface and the second thing is what we can do is we can extend a thread class and we can instantiate that uh extension of the thread class as we did for here. Okay. Now let's take a look at the thread class a bit. Wow. Do you see this? This thread class also implements runnable. Then why is it asking me to pass a runnable object to it? Right? And one more thing is very interesting actually. This thread class implements runnable and this is not an abstract class. Right? We can instantiate thread if you want. So if you want to instantiate thread, we can do this. You can do new thread. Okay? I mean this thread I'm talking about the thread actual original thread class, right? Which you're trying to imple which we're trying to extend over here. Okay. And new thread and we can also do run right then why are we doing all of these things? Why are we creating a object of runnable interface or why are we creating a thread that extends the this thread class? Right? Because one thing is for sure since this thread is implementing the runnable interface it has to give a concrete implementation of the run method right and I can also call the run method right you can see so what happens if I call this run method let's see nothing happens you see nothing happens cool so now the question is that what this run method is doing actually this run method is doing nothing and I would tell you why see this this thread class has an object of runnable interface that is here. Okay. So if you go here you would find it has an object like object called target right uh basically an attribute called target which is of type runnable interface. Okay. And initially it is null. Okay. So now if I try to run this it will just check that hey like let's say for this particular I'm just debugging this right new thread. I just create a new thread. I create this object of the thread class that is java.lang.thread class right and I call this run method. So what happens is it says okay the target is null so it won't even enter this loop right and it will come up and that's why nothing is happening very simple now what we have to do in order to call this run method okay so in order for your code to reach here right uh and uh in order for you to call this uh run method what what you ideally need to do one thing that you can do is you should have to ensure that this target object is not null right and in order to ensure that you are passing an object object of runnable interface to the constructor of this thread class that we were doing here. Okay. So what this what is this thread two? This thread two is nothing. This thread 2 is implementing a runnable, right? And it has its own run function. So basically what it is doing is it is just we are just passing we are just passing an instance of runnable to this thread class java.lang.read class which is what it is doing is it is basically setting that to target. Right? Right? So whenever you're passing an instance of runnable, it is doing in the constructor, it is doing target this.target is equals to that in that that instance that you just passed. Right? So therefore whenever the JVM is calling the run method, it finds the target is not equals to run and hence it calls target.r run which ideally means the run method the run method that which you implemented for your particular class which is implementing the runnable interface that is the run method of this thread to class that is getting called. So that is why one of the way which you can do is to create a thread is so pass a runnable object to the thread yourself. Right? So if you do that then your problem is solved. So now the target is not null for this particular java.lang thread class and it is able to call your run method. What is the other way? Let's say you don't want to pass your own instance of the runnable. What is the other way we can do? The other way is you can extend this particular java.lang thread class and to provide your own implementation of the run method. So what we were doing is in thread one what we were doing we were overriding the sun method right and in the main class what we were doing is we were like we were instantiating our own class that extends the java.lang the thread class so when we call start or like which will in turn call the run right because we know that when we call the start in turn the JVM will call run at some point of time right then there is a metal overriding that is taking place because this is an instance of our our own thread class that extends the java.lang lang thread class. Therefore, our run method will be executed like the run method that is here. This will get executed instead of this method because of method overriding in Java. We all know that concept, right? Method overriding when does it happen? When you try to instantiate an object of a child class, then the that overridden method of the child class gets executed. Right? This is these are basics of method overriding in Java. Right? So that is what is happening. So, so therefore, therefore the design of the class entails you to like start a thread or call the run method of this thread in two ways, right? Because you see over here that that either what you have to do is you have to set this target to null. So that because you can see from this piece of code that there are two things that you can do, right? One is either you set the target uh not equals to null. That means you provide an implementation of the target that is you provide an implementation of the runnable interface. So as a result what happens is then you are run like that that whatever object that you're passing right it run method would be called right so that's why we pass the runnable interface we create our own unable interface and we pass it right and the other way you can what you can do is you can say okay don't even call this method I will extend this particular thread class and I will provide my own run method so by method overriding my run method will be getting executed right so that is why there are two ways of creating a thread one is either you pass a runnable instance which will set the target which will set this target of the thread class to your instance and then your instance run method will be executed or else you extend this thread class and you overrite this run method that's it no one will tell you this uh I can assure you about that like everyone will be telling that hey there are two ways of creating a thread like either you like pass the runnable interface or you extend the thread and override the run method right this is actually why we are doing this okay so this is the logic behind being having two ways of creating a thread okay so now you might ask me a question that hey this is confusing. There are two ways of creating a thread. Which one should I choose? And this is something that interviewer might ask you as well in your interviews. And your answer should be hey if I try to follow this method by extending a thread class. What if my class wants to extend some other class as well? Then what would I do? Because I know in Java I cannot extend multiple classes. There is no concept of multiple inance in Java, right? I am constrained over here. But hey, if my class wants to implement some other interface apart from runnable, I am allowed to do it because Java do support implementing multiple interfaces. Multiple interfaces implementation is supported in Java. But multiple inheritance that is extending multiple classes is not supported. So here I don't have any constraint if I'm implementing runnable but here I am having a constraint if I'm extending the thread class. So the better way is implementing the runnable interface and that's what we should follow and we will follow through to through to the course of this video and that's what mostly all developers follow and that should be your answer to the interviewer. The answer should be pretty simple. I should be implementing runnable all the most of the time because I I won't have any constraint because I can do multiple implementations of for a particular class but I can't extend multiple classes. So that's why extending a thread adds some constraints to our design. Cool. So that is why say by to this method as of now right that means we are going to always pass a runnable interface whenever we are going to create a thread at least for this video. Now one more thing here we what we what we did was we first created a class that is thread 2 that means that implements the runnable interface we implemented the run method right and then we pass we created an instance of this uh object and we passed it to the thread we are going to replace it with lambda right so again if you have if you don't know lambda uh I would don't worry too much don't get too much deep into it I will tell you what exactly is happening but yeah I will make a separate video on lambdas as well because the reason I'm trying to give you the lambda implement mentation of the code because you will find most of uh the thread code that is written everywhere is in lambda right now. Uh so yeah that's why I wanted to tell it to you guys so that you don't get confused and we would be using lambdas to create thread throughout your course right. So basically what I would do is whatever code you would write in inside the lambda function or in the run function that code you would be writing here. So basically what you're doing is you're passing the implementation of the run method as a parameter. That's what it is doing. And the compiler in turn what it would do is it would understand oh okay okay this thread constructor it accepts implementation of the runnable interface. So let me for what it will do is okay and it it has passed me a like a method as well. So what the compiler will do is uh it will create a class uh that implements the runnable interface inside the run method. It would paste this code and then it would instantiate that object of that particular class and it would pass it. So the compiler will take care of all that boiler plate code. You don't need to go and like separ sep separately create this class that is set to class like the class that implements sun then implement run methods do the overriding and all those boiler plate things you don't need to do. you just tell to the compiler hey just I will just write the uh like the uh run function and you do the boiler pit stuff right similarly what we were doing while we were learning comparators right in prior Q while passing comparators to priority Q sets and all so it's very simple right it's basically lambda so there's nothing to do so yeah we will just passing for now you can consider like this we're just passing the implementation of the run method to this thread right and you're passing the thread name we'll be using that throughout the for this entire video okay So these are the two ways in which we can create a thread. Uh let's quickly sum up what happens. So basically now when you are creating a runnable object like when you're creating a thread by passing a runnable object first what you do is this is the current thread or you can consider it as a main thread right then you create a runnable object and then you create a thread object and there you pass the runnable object as a parameter right along with that you can also pass the string the thread name right if you want to then it creates a thread and then you call the start method of that particular thread. Now this start is an asynchronous function. So it returns immediately, right? The call returns immediately. But you see that there is like the thread doesn't start. So the run method of this thread is not executed straight away. There is some time gap, right? There is some time gap and after that the run method is executed, right, by the JVM for this particular thread. And now once this run method is executed, a new thread, a new thread begins, a new thread of execution begins. So this current thread is like like executing and par this thread is also executing. Okay. Now let's also try to understand that what if we create a an object of a class that extends a trade class. So what we do is we create that uh we instantiate that class right and then we call the start method. Again there is some gap between the when the run method of that particular thread is executed. So the start call the call to the start method returns immediately. But after a certain point of time the run method is being executed. You don't need to explicitly call the run method. ever call the run method explicitly. The JVM will take care of it. You just call the start method and wait, right? Then this run method will be called and then once this run method is called, there are two threads that are running parallelly or concurrently. Okay, so this was about the threads uh creation. And if this is very clear to you, now let's look at a very very important concept that is synchronization from which you will be getting most of the questions in interviews and also it's a very very important topic that you need to know if you want to be a Java developer. Okay. So now let's understand what is synchronization and what is the need of it. So as I told you that the threads share the same memory space that is they can also share the objects right. So let's say in that memory space if there is one particular object all the threads will have access to the same object right because there all these threads are kind of manipulating or working in the same environment in the same memory space right and there might arise some critical situation in which it is it might be desirable that only one thread at a time have access to that shared resource right consider a use case where you're implementing a movie uh ticket booking application right and there is a field called remaining seats inside a cinema hall and there are multiple threads that is taking care of multiple users to book that particular cinema hall seat and now what happens is that let's say if two threads basically what will what will a thread particular thread do it will check okay if the remaining seats is greater than zero then book uh book the cinema hall seat and decrement the remaining seats by minus one right so now let's say the remaining seats is one and the three threads okay they simultaneously try to access the remaining seats variable and all of them check at hey like let's say the first step checks the variable okay and it says remaining seats is one so now it it it is trying to now update the remaining seats it's first does the check that okay remaining seats is greater than zero so it now it is trying to book right and then it will uh like update the remaining seats and by decrementing it right but when it is trying to book right like understand the book operation is heavy itself and it like involves making some DB calls and all so by the time it is doing that operation the other thread also comes in and it checks hey this this remaining seats is greater than zero. So also let me book it as well. And that is something we call a race condition. Right? And that is that is not desirable. We will see that in action as well. But what we have to understand is there might arise some situation and where it is desirable that only one set at a time can access that shared resource. The shared resource in this example is that remaining seeds variable because that variable is very critical because I don't want all the threads to access it all the time, right? Because it's constantly chopping and changing. Okay. So now let's take an example where actually this critical situations might arise and I'm going to exactly like create the critical situation and we will see then why do we need such a situation where we would ideally want one at a time to access a particular resource or access a particular code block. Okay. So let's now jump to an example. Cool. So let's create a stack class. I'm not creating a generic class because you might get a little bit intimidated since I'm not taught generics yet. So what I would do is so inside a stack I would need an array right. So I will call it an array. Okay that would be basically the building block of the stack and also I would be creating uh I would be maintaining the stack top right stack top index. Now I have to pass in the constructor capacity like what is the capacity of this particular array or what is the capacity of this particular stack. Okay. So what I will do is I will instantiate this array to new int of capacity. My stack top would be set to initially minus one because there is no elements. Right? Now there are two methods that I have to write. One is public boolean is empty. If the stack is empty or not. So if the stack top is less than zero then I know the stack top uh that the stack is empty right which is currently the condition. Now also when I will know the stack is full that is whenever the stack top is greater than equals to array do.length minus one that means the stack top already is at the location or the at the last location then I know that hey stack is full and we can't allow any more elements. Okay, so I just pasted two functions that is the push function and the pop function just to save a little bit of time because I really don't want to waste time uh like uh writing the code for push and pop in front of you. Uh so basically what I did is what this push function is checking is if the stack is full then return false. Obviously we can't you know push it. If it is not full then we are increasing the stack first then we are trying to sleep a bit little bit right and then okay by the way if you don't know what this this is so again in the thread class java.lang.thread thread it has a sleep method right which basically takes a parameter in milliseconds. Uh so this means that 1,000 millconds means that this thread will sleep for 1 second right and it throws an exception that is an interrupted exception. We will see all of these things when we will be like reading about the thread states. But for now try to understand that if you if you write this piece of code thread dos sleep and if you pass a parameter in milliseconds it basically sleeps that thread basically sleeps for that period of time right uh execution is blocked for that period of time as well since it has a exception that it can throw that is like an interrupted exception. Therefore we have to catch the exception right so that's what we are doing. Okay. So we are making this thread deliberately sleep for you know 1 second. Then after that what we are doing is we are saying okay uh like inside in in the stack top like put this element and return true right similarly for the pop what we are doing is we are saying okay if it is empty then return some infinity value right and if and we are not like we are not like obviously it is empty so what we will pop right so first we are getting the value from our current stack top and we are invalidating our stack top because we are going to decrease our stack top. So obviously that value makes no sense. That's why we're invalidating that value by by placing an infinity value as a placeholder. Then we are trying to like make this sleep thread sleep right for 1 millisecond and then we are decreasing our stack top and then we are returning the value that we just popped out right. So this is basically uh a basic stack right now back to the main class. I pasted a little bit of code as well. So I've created an instance an object of the stack class with a capacity of five and now we created two threads right. So what we are doing is inside the thread we are passing this basically we are passing the we passing the implementation of the run method. Right? And in this run method what we are doing is in this thread one we are saying that for 10 times push push 100 to this particular stack. Try to push 100 methods to the stack. And again we create another thread where for 10 times we are trying to pop from that particular stack. Right? So there are two threads running paralle. one is trying to push 100 to the part to the same stack and there's another thread that is trying to pop from the same stack. So ideally what should happen like one thing we have to note here we don't know whether this push method is going to be called first or this pop method is going to call first because these are two different separate threads. So we don't know exact sequence order in which they will run. So what if if we try to you know pop elements from the stacks first up right in that case if there are no elements it should be okay. It should just return me an infinity, right? That means there are no elements. So let's say if the push method got executed first, then I would get some elements, right? So let's run this code and see if this actually works or we face an issue. Okay? Oh god, we run into an exception. But why did this happen? We were actually like we had done the checks, right? We had already we had done all of the checks like we have checked that if it is full false then return false. If it is full then return false, right? And if it is empty then return like a negative value. So still why are we still running into this array index out of bounds exception. So what might have happened is when this when it when the when the push pusher basically pusher thread called this increase the stack top right and it was sleeping by that time the popup thread might have come over here and might have decreased the stack top to some negative value and as a result what happened was this stack drop became minus one and since there was no check involved over here that whether it's a valid index or not it is it ran into an array index of out of bounds exception so basically what I'm trying to say is there will arise certain cases where I cannot allow two threads to run parallelly, right? Or to run parallel for a particular method or particular methods, right? So, we have, you know, in collections, we have thread safe classes that exactly does the same thing where we basically ensure that the class is thread safe, which which basically means that multiple threads even if they're trying to access that particular class uh it it won't run into trouble or the class won't run into an inconsistent state as it is running into right now because this class is definitely not thread safe. And also uh the problem that is happening is this this class is running into an inconsistent state right because this stack top is the value of the stack top is getting changed in the way it should not have been ideally when two threads are running this this piece of code is perfectly fine there's nothing wrong with this code if you just run in a single single single threaded environment but once you run this in a multi-threaded environment this stack class creates a lot lot of problems for you right and we run into exceptions so in order to deal with this we have to ensure that especially this push method and the pop methods right especially the two methods which actually uh is changing the state of the particular stack object right I mean empty and isful if you consider carefully these are not changing the state of the object just checking the current state that's it but they're not changing they're not updating they're not mutating the current state but push and pop are those two methods which are changing the state of your current object right and you can't allow you can't allow multiple threads to change your state in such a way, right? Because if you're allowing multiple threads to have access to the functions that keeps on changing your state, then it would run into inconsistency very soon. Right? And that is the reason what you should do is you have to deise a methodology where you will say, "Hey man, my function should only be accessed by one thread at a time. The first thread will continue. That means that even if the thread is sleeping, no other thread will execute other functions, right? Or this function, right? And I will first complete and then I would allow other threads to continue, right? So basically, think of it as a door, right? And let's say there are multiple threads waiting outside the door and there is this stack top or some shared resource, right? That is there inside the door. But in order to get into that door, it will allow only one thread to get into that door, do all the operations that it wants to do with the shared resource. come out of the room and then only you will allow other threads to enter. Now how will you delegate that? How will you say okay which threads will now enter the room that is being done by concept of locks. So whichever thread will have the lock whichever thread will acquire the lock to that door he will be able to he or she will be able to enter the door do all the work with his shared resources and find fully complete its work get out of the room hand the lock to uh JVM. The JVM will then hand the lock. It will not directly hand the lock to the other thread. It will hand the lock to JVM. right? Or the CPUuler whatever it is right whoever is going to schedule and that scheduleuler is going to then decide that okay which thread it should give the log to right by the basis of scheduling algorithms that you read in OS operating systems and then the on the basis of that the other thread will go in it will now do things do its things complete it things with the shared resource and then it will come back right so in order to ensure that only one thread at a time right only one thread at a time is able to access this particular ular resource or this particular piece of code that access this particular resource we have to use the synchronize keyword right or we can we can also use the locks but locks is something that I'm not going to cover in this video because most of the time we are going to cover synchronized but I'm definitely going to tell you the concept as well so what are we doing is we are creating a synchronized block right and inside that block inside that block what we will do is we will put this piece of code similarly for this we will create a synchronized block and we will put this piece of code. Okay. Now it gives an error. Why? Because when we declared the keyword synchronized, right? And when basically this is a synchronized block. This is something what we call a synchronized block, right? Because this is a block, right? This is a block. This piece of code is a block within curly braces. And we like we are saying this is a synchronized block by using the synchronized keyword. So now what it tells is hey this code is a critical section. So whatever code you write between the synchronized keyword is a critical section right you have this in OS I guess. So now you are saying that hey this is a critical section. This is a critical part of the code and I won't allow more than one thread to access this particular block of code right and that is why this block I'm declaring as synchronize. That means only one thread can access this block at a time. But hey wait, how will I know that which thread uh would be able to access this particular block? For that I told you that that thread will need to acquire a lock, right? That is important. If whichever thread will have access to that lock, right? It will be able to enter this critical section and execute that piece of code, right? So in Java, how would you define that lock? Luckily, luckily we don't have to do much anything fancy because the synchronize basically needs a lock right synchronize says okay the synchronized block says hey what is the lock what is the lock on basis of which I would understand that hey which thread will get in right so as I said in Java every object can use this lock every object now this blew my mind away completely when I first read about and while back in my college days uh but yeah I mean that's what it is right so every object object in Java not not any primitive data type. So int cannot be int being a primitive data type cannot be used as a log but wrapper class of int that is integer can be used as a log. Okay. So integer not it won't be integer but yeah an instance of integer can be used as a lock. Okay. So an int a primitive int a primitive integer can be used as a lock right but a wrapper class of int can be used as a lock right. So in this case what we can do is we can create a object any object right and we can just do object lock right and lock equals new object right and we can just pass this lock we can just say hey this this if whichever thread access to this lock it will enter this critical section and this lock object we have to pass now here we explicitly created a lock object instead of creating explicitly a lock object what we can also do is we could have done let's say new string new string string SS because that is also an object right instead of that we could have also created our own any anything we could have just created anything right we could have classed new object here as well we could have done absolutely anything right but here I'm passing this instantiation of this lock object right so whichever thread will have access to this lock it will enter this right so you can understand in Java in a synchronized lock you can use the the lock object basically I mean you can use any object as the log. Okay. Also one more thing now you have a question these these are pretty critical questions. Okay. So now the question is that let's say if a thread if multiple threads is trying to access the push. Okay. Now let's say there are three threads. Okay. T1, T2 and T3. Okay. And let's say here there is the same thread T1 here and let's say T4 and T5. Okay. So now let's say T1 is trying to gain access like it's trying to gain access to the lock so that it can execute this method and it's also trying to gain access to this lock like the pop method lock as well so that it can gain access to the method and whichever lock it will get. Now let's say if T2 gets the lock right it gets to access this method it it it it might it will get access to this method it would be able to execute this method then in the meantime T1 is waiting for this lock right but T1 can't go and execute the pop method because these two methods are bounded by the same lock the same lock object right since since and this lock object can only be with one at a time, right? So therefore, since both these synchronized methods are bounded by the same lock object again again this both two synchronized methods are bounded by the same lock object. So therefore whichever thread gets access to this lock, he will be only he or she will only be able to access any of these methods. Other threads will have to wait. These two methods might be completely different from each other. They might be completely different from each other, but since they're both bounded by the same lock, therefore, whichever thread has the lock would be able to access that method, right? And so now T1 might not be executing this, but he also won't be able to execute this because this lock this lock is with T2, right? But let's say let's say I create another log object, right? So let's say I make object a lock this like lock one. This is like lock one. And similarly I also create another lock object like let's say log two equals new object right and here so let's create log one and log two okay and here this is log one and here this is here this is log two okay so in that case t2 let's say it gets the access to log one then t1 might get access to log 2 and then they can like execute parallely because these are bounded by two different logs right imagine there are two two different doors, right? When you have two different we're talking about two different locks. Imagine you have two different doors, right? So that is basically the thing. So you have to understand that if a particular synchronized method has a lock and that lock also restricts access to other synchronized methods as well, all the access to the synchronized methods will be blocked for all other threads that doesn't have that particular lock. So that is very important. Right? Now in that case, what do you want to do? Just think for a moment in this push and pop case. Do you want to have two separate locks or do you want to have one separate lock? So let's say there are two separate locks. One for push and one for pop. Then what happens then? That means ideally I'm allowing two threads to simultaneously run the push and the pop methods. And that is basically what was exactly happening when we were run when we uh like running the pusher and poper methods without having the synchronized block. So it doesn't solve our problem. Having two different logs for two synchronized methods doesn't solve a problem for this particular use case that is push and pop. So ideally I would want when the push is getting executed other threads won't be able to call the push that is fine but also it won't be able to call the pop as well right because previously what was happening someone was calling the push someone was calling the pop and they were like changing the state stack top and leaving it into an inconsistent state right so therefore we would want the same log to be used for push as well as same log to be used for pop block as well right that will ensure if it has the same log that is log one or lock two or let's say let's let's go back to this previous lock right that what it will do is it will ensure that hey when a thread is executing the push method no other thread will be able to execute the push method and also no other thread will be able to execute the pop method as well because both are bounded by the same lock make sense this is very important okay so in a class in an object if if the multiple synchronized methods are bounded by the same block. You have to understand that whichever thread has that block only that thread will be able to execute all the methods, right? Other threads will be blocked. Cool. So this was about synchronized blocks. Okay. Now let's say that you want to make the entire method synchronized. For this you can see that this actually what we are doing I mean we are enclosing all the entire method in a block. Okay. So instead of doing that what we can do is we can just make this method synchronized as well. So there are two ways of making a code block synchronized. Either if you want to synchronize the entire method then don't use a synchronized block and then just apply synchronized on the object method itself on the method itself. But if you want a particular piece of code within that method to be synchronized then use the synchronized block. And remember whenever you are using a synchronized block you have to use a explicit lock. Explicit lock is required that we were using over here that we created a separate this lock object. But whenever we are using the synchronized keyword for a method that means when you are creating a synchronized method we don't need to pass explicitly any log object. But then your question might be then in this case what is the log that is being used because there I was passing the lock right there was I was creating a lock and I was passing it. Okay but in this case what is the log that is being used because there would be some log associated I might not be passing it but behind the scenes something might be happening right? So behind the scenes that is nothing but wrapping this entire piece of code by using this. This is basically what is happening. You're wrapping this entire piece of code. So this the compiler will translate this into this. That means this instance of the current object is used as the log. Remember that log can be any object. Lock can be any object. So whenever you are saying that the method is synchronized in return in in behind the scenes the compiler it is using the instance of this current object as the lock right and also therefore what happens is now for both the methods since you have declared both the methods is synchronized and behind the scenes you would using the object lock is basically the instance of this object right so therefore what is happening is for all the synchronized methods for all the synchronized methods in your class the lock is what The lock is the instance of this current class. The instance of this current class that is this keyword basically. So therefore the lock is the same for all the synchronized methods in your class. And therefore if you have like multiple synchronized methods in your class synchronized methods in your class which ideally means that the this is the lock right this keyword is the lock or the instance of this object is the lock. That means only one synchronized method will be able to execute by a particular thread at a time. At a given point of time only one thread will have access to all synchronized methods. Right? Even if they have nothing common in between still that will happen because the lock used here is same. Okay. So that is synchronized block and that is synchronized methods. I also learned the concept of logs as well and every object can be used as a log. So now what happens in case of static methods? How do we synchronize static methods? In that case, what we do is we synchronize on the class log itself. So what is a class log? So basically this is nothing. So if you go to the singleton video, if you go and watch my singleton design pattern video, uh I will just open it from here as well. So here what we were doing is we were like having this TV set, right? And this is this was a static class that we created, right? So in a static context we cannot use this because it is static right that means the there is no object there is no instantiation. So in that case we use TV set that is the class we use basically this that means uh basically this is reflection API uh don't need to delve too much into it right now because that will be a huge digression all I want to say whenever you're thinking of a static whenever I think of using a synchronized block inside a static method you know that you don't have this you don't have any object instantiation right of of the current object so in that case just take the class name and write dot class that that will work fine Okay. And whenever you're declaring any static method as synchronized, let's say if you want to do this in that case behind the scenes, here the compiler was using this here it will simply be taking the class name and it will be using stack.class as the lock. That's it. So in static synchronized methods this this is used as lock and in case of non-static methods the this keyword or the current object reference is used as lock. Right? Also summing up, so while a thread is inside a synchronized method of an object, all other threads that wish to execute this synchronized method or any other synchronized method of an object will have to wait. This restriction does not apply to the thread that has already has the lock and is executing a synchronized method of of the of the object. Such a method can invoke other synchronized methods of the object without being blocked. The non-synchronized methods of the object can be called at any time in the thread. Okay. And also let's look at the rules of synchronization as I mean I've already discussed it but let's sum it up. So a thread must acquire the object lock associated with a shared resource before it can enter the shared resource. Okay. The runtime system ensures that no other thread can enter a shared resource. If another thread already holds the object lock associated with it. If a thread cannot immediately acquire the object lock, it is blocked. That it must wait for the lock to become available. When a thread exits a shared resource that it exits the door, the runtime system ensures that the object lock is also relinquished by the thread. That means the thread gives away that lock. It doesn't hold such a lock with it. If another thread is waiting for this object lock, it can try to evacuate the lock in order to gain access to the shared resource. Okay, it should be made clear that the program should not make any assumptions about the order in which thread are granted ownership of the lock that is completely up to the scheduling CPU scheduling or whatever JVM or whatever platform it is on. Okay. So now you might question that why are we using the sleep method over here, right? So this sleep method increases the chances for the state of the stack being corrupted by one of the threads while the other one is sleeping. Right? So that is why we are using the sleep method and we will see that in action very soon that what exactly might happen. Okay couple of more things. A thread acquiring the lock of a class to execute a static synchronized method has no effect on any thread acquiring the lock of any object of the class to execute a synchronized instance of method. For example, in the same class, if there is a static synchronized method and there is a normal synchronized method, there is no stat non-static synchronized method, right? Those are not interlin. Those can run separately because you know it's a static synchronized method, the lock is dot class and here the non-static synchronized method, the lock is this. So therefore the locks are different. That means they can independently execute. Okay. So that is why synchronization of static methods in a class is independent from the synchronization of instance methods on the objects of the class. Also whenever a class is extending another class there are some methods if it is trying to you know override that method the subclass will now decide whether the new definition of an inherited synchronized method will remain synchronized in the subclass. That means it will it might choose to keep it synchronized or it might choose to not keep it synchronized. Okay. Also now what is race condition? This is a very important question. So basically it is nothing. It occurs when two or more threads simultaneously update the same value in this case the stack top index right and as a consequence leave the value in an undefined inconsistent state. So we were we didn't make the push and pop synchronized initially and as a result there was a risk condition that happened leading to an array index of out of bounds exception for the uh stack right we already seen synchronized locks right so there is nothing much just in just one thing for a synchronized block we have to pass an explicit lock so if the expression evaluates to a null then the null pointer exception is thrown okay so now let's quickly look at the summary a thread can hold a lock on an object right by executing a synchronized instance method of the object Right? Which is basically the this keyword by executing the body of a synchronized block that synchronize on an object. Right? Again, you can use the this method, this keyword or any other object by executing a synchronized static method of your class or a block inside a static method in which case the object is the class object representing the reflection API class in the JVM. Okay. Now what is thread safety? It is a term I mean it is basically just for interviews because a lot of times you get asked what is a thread safety. So basically thread safety is a term that is used to describe the design of classes that ensure the state of the object. The state of the object is always consistent even when the objects are being used concurrently by multiple other threads. For example, string buffer is a thread safe class where string builder is not. Right? So this brings us an end to the synchronized block section. It's good time to take a break. Okay. So now let's learn a very important concept that is the volatile keyword and it's often asked in a lot of SD2 interviews. is also used in singleton pattern and it's not a very easy concept to grasp and very few people know about it right so if you're a fresher you're watching this video uh I can assure you that this is something you can learn and brag about your classmates because very few people will actually know about this and this is not a very hard concept to grasp however it is not very easy to figure out that where to use this particular keyword okay but I will try my best to let you guys uh understand this keyword so volatile is a keyword in Java and now let's see when does it usage can actually come into Okay. So suppose there are two threads, right? And you know what happens is a thread interacts with your CPU, right? And the CPU in turn interacts with the main memory or the RAM. Now let us introduce our friend cache which basically helps us in reducing the access time. So we know that it is far more efficient for a CPU to access data from the cache than uh for the CPU to access data from the main memory, right? And that's why cache comes into picture because it gives you fast data access time. So what happens ideally is whenever uh there is a shared variable that exists in the memory. When I say shared variable you can consider the top of the stack right which we saw in the previous example right and that is a shared variable because multiple because that variable exists in the main memory and multiple threads are actually trying to access that variable and work on it and maybe update it or you know whatever it wants to do with that particular shared variable. So let's consider here we have a shared variable who which is a boolean flag variable and initially it is set to true. Okay. So now what happens is this thread both these threads they don't directly read from the memory they have their own cache and they read all these threads read from read the value of this flag variable locally from their cache. Now the problem that might happen is if let's say thread 2 changes the value of this flag to false. It won't directly update it into the RAM. it would first update in its local cache. Right? So you can see here it updates the flag variable to false but the other thread still can see the value of the thread as true because it is not updated in its local cache as well as in the main memory. It is still true. Now next step it will take some time for this value of the cache to be propagated to the main memory as false because there was an updation that was being done by thread two. But you can see the thread one still doesn't have any visibility that hey this flag is actually changed to false. In order to get rid of this problem we introduce the volatile keyword. So if you declare the same variable as volatile that is volatile boolean flag equals to true. Now what happens is this threads no longer read it from the cache or from the local copy. They directly read it from the main memory. As a result if the thread two changes if the thread two changes this flag to false the thread one will have access to it. Right? just in case where let's say there is there is the status right there's a status flag uh that is constantly getting updated by multiple threads and based on the status flag the other threads are you know doing some work right I mean the condition of that status flag will actually direct that how the threads will behave that is very important for all the threads to to have a consistent uh state of that particular flag variable I will give you an example if you remember my singleton pattern video if you haven't checked out my singleton design pattern video. I would highly recommend you to go and check out that video. But I will just give you a brief. Okay. So now let's take a look at the singleton class that is the TV set which we created while I was uh recording my singleton design pattern video. So here what happens is what does a singleton design pattern say? I will just briefly tell you. So in a singleton design pattern you can create only one object of that particular class. Right? So we have to design the class in such a way. Okay? So that only one object can be created for that particular class. So what we do is we maintain a static variable of the of the instance right and initially we set this to null right because let's say that when this when there is no object created uh the instance is null right and we declare a private constructor we create a private constructor because we don't want uh any other client to instantiate this class from outside okay so if now what if any client want wants to instantiate this particular uh particular class right so For that we create a static method. Right? Now why do we make this constructor private? Why do we make a static method of get instance? All this I've covered in depth in that singleton design pattern video. Uh I'm I'm not going to cover that in such depth. But for now just want to say that basically we don't expose our constructor. We expose this static method which basically checks that okay whatever this instance if this is null that means no object has been created for this particular class. In that case, we go ahead and we create an instance of this particular class and we before returning that instance to our client, we store it. We store it uh we'll update this reference variable uh to the new instance that we just created. And so the next time if some other client wants to again instantiate by calling this uh get TV instance object. What we do is we return this particular this particular instance and we don't end go and create another instance. Right? As you can see only if it is null only if this instance is null then only we create a new TV set otherwise we return uh otherwise we don't create any new TV set and we just return the same old instance in that way we ensure that only one instance of this object is always created right like again why this is synchronized why this is like why we are having two checks right all these things which are which you call double check blocking and all these things I've covered that in the singleton design pattern video so it is highly recommended you go and check out the video after you have watched this multi-threading videos but here you can see that there is a flag right there's a flag that is this TV set instance this this TV set instance is acting as a flag right why this is acting as a flag is it says that okay if this if this reference is null then create an object otherwise don't create an object return that same object so it is kind of acting as a flag right that that particular variable the state of that particular variable defines like the the following operations right so now let's say in a multi-thread environment multiple threads are trying to access this class and let's say one of the threads one of the threads get access to this class and it updates this TV set instance. Let's say first thread comes in uh and first thread comes in and it checks that okay this TV set instance is null then let me create a new TV set instance uh and I and let me return it. Now let's say this first thread has created this new TV set instance and it has updated its value and it has returned it. Right? Now if you go back here you see that what this thread did it updated the TV set instance value in its local cache but it is not yet propagated to the main memory and let's say next is propagated to the main memory but it is still not propagated to the other thread's cache. So the other thread if now if it again want this other thread now wants to create a new instance it will find in its local cache that hey this TV set instance value is still null and as a result what it will do is it will again go and create a new object. So now there are two objects being created which kind of violates the singleton design pattern principle which says that only one instance of an ob of this particular class can be created and that is the reason I want this this flag instance variable to be directly updated in the main memory and directly read by the thread from the main memory and that is the reason we declare it volatile. I've also explained in that video as well but this is more an extensive explanation on on volatile keyword. So I hope you're able to grasp this concept because it's a very very important concept. uh it's not very easy to understand it where to use volatile in all of the cases. So that might require a lot of design discussions and profiling but yeah that's that's mostly about volatile. Now let's look at another problem uh which is again a very famous interview problem that is the producer consumer pattern problem. Now let's say there is a cube okay and there are different types of threads. Okay let me divide the thread into two groups okay one group of threads is trying to push items to the queue. Another group of thread is trying to remove items from the queue. Okay? So we can only push items to the queue if it doesn't increases the capacity like as we saw in the stack class right and we can only pull out items from the queue if there is any item that is left in the queue. Okay. So now uh in order to like set this up in a multi-threaded environment we already had a flavor of this in our in our stack class. So let's do it similar to for Q's. Okay. And there can be situations where multiple threads are trying to like add items to the queue and multiple threads are trying to pull out items from the queue. Right? So here we have we have made this class that is called that we call a blocking Q. Why this name? I will tell you later. But for now let's create a Q. Right? And let's we'll also maintain a capacity. Okay. So let's say Q integer Q. We will import it and also let's maintain the capacity. uh I will declare it as private and I will also declare it as private. I will get a constructor create a constructor for this class int cap capacity is equals to cap okay and let's say I will also have to instantiate this cube I have to import the link list as well okay now we have to implement two methods that one is public boolean ad boolean because I want to return whether uh the ad was successful or not and this will be an int item and another method is public int remove and that will remove the uh item from the top right so now we saw in the last video that we have to move uh since multiple threads are trying to access this so we have to use a synchronized block here and we have to use this right uh or maybe we can uh not use this maybe we can use the Q as our lock because we are trying to lock on the Q right so therefore we can use the object of this Q class as our object lock for the synchronized block okay uh similarly we have to also put this remove piece of code inside a synchronized block as well because we have already se seen this in stack class that multiple threads are trying to access it and therefore we have to ensure that this particular Q is not accessible by multiple threads at one go whether they irrespective of whether they want to do different operations on the queue because if you allow multiple threads to have access to this Q then what happens is it will leave it can lead the queue to inconsistent state right please refer to the last part of the video that we just saw in that therefore we have to like put this piece of code in into a synchronized block okay and the lock used is for this particular Q please note that we're using the same lock okay there therefore as a result what does it mean is one of the thread will get access to this lock that is the Q object and therefore only one thread would be able to access either add or remove at a time. Basically only one thread can do operations on that particular queue right be it add or be it remove before adding an item I have to check okay if Q dot add Q dot size is equals to equals to capacity okay in that case what if what if this happens right if the Q dot size if it is equals to equals to capacity in that case can I put things into the queue no right because the Q doesn't have any room to allow more items into it because it will otherwise it will exceed it capacity. So what in that case what should we do? Okay, that's something will come later but for now what if what if that's not the case and there is like we now we have space to put items into the queue. So in that case we will simply go ahead and add the item into the queue. Okay and we will return a true okay that's it. Now here we have to do something right and I'm coming back to this but before that let's also implement the remove function. Okay so let's say here also first I have to check that if Q dot size is equals to equal to zero then I have to do something right because I can't remove items in the queue because there is no items left to be removed. But if that's not the case, else if that's not the case, then we can simply pull the item and return it. So I will take it into some variable and element is equals to Q dot pole. Okay. And I will return that particular element. Okay. Now let's come back to here these two fillers. Okay. So in the add method what if the Q has already its value equal to the capacity. In that case what should the thread do? Okay. So now as I told you that you know there are two types of threads. One thread group that is that is like trying to add items to the queue and one another thread group that is the uh that is the remover thread group. It is trying to remove items from the queue. Okay. So since I have marked this as synchronized only one thread only one thread from any of these thread group would be able to access this critical section right so it can be this or it can be this right depends on whichever thread group pins so let's say and it is trying to acquire the same log because the lock is the same right the lock is the Q object right so now let's say that the remover one of the threads who are trying to remove right he got access to this lock he wins the lock for this Q object and he has the Q object block, right? So therefore, he has now access to this particular critical section because obviously he because he gets a chance to run and when he gets a chance to run the remover thread gets a chance to run because he has this Q lock other threads will be blocked. All other threads will be blocked, right? Respective of the group and it will call the remove method and now it will enter this loop, right? So now what happens is initially there is no items added to the que therefore it checks that hey the Q dot size equals to zero, right? So now what happens idle is because no items have been added yet because the remover thread first won the bid first has had the lock first acquired the lock. So now the situation is that this particular remover thread has the lock and it is it has now the opportunity to execute the code in this critical section but turns out it cannot because the size of the Q is zero. So if the size of the Q is zero, how can it remove an element? Right? So now the situation is like this. This remover thread has access to this code block but it cannot execute the code because the size of the queue is zero and it has nothing to remove. Right? Since it has access to this critical section block, the other threads other threads even the other threads who can add items to the queue to potentially unblock this remover thread. Okay, they are also blocked because they they don't have access to this queue right now because this remover thread is executing. So what does this remover thread do right now? Because it can't execute. It can't go and remove items from the queue otherwise it will run into an exception, right? Because the queue doesn't have any item. So in that case what this thread has to do is this thread it has to wait it has to wait for a condition and what would be that condition? The condition is it will wait till any other adder threads adds any item to the queue. Right? Because if any adder thread adds any item to the queue then this particular thread is now sure that hey I can now go and remove an item from the queue. So again this particular thread has to wait and it will how long will it wait? It will wait for a condition to be true and what is that condition? The condition is the condition for this remover thread is that whenever there is an item being added to the queue right then only I can unblock myself from the weight state right and I can again start executing. Now if this is still confusing to you watch this practical implementation and later on when we watch read about the thread transitions this will be ever more clearer to you. Okay. So this object class object class has two methods that is wait notify and notify all object class already has implemented this methods. You don't need to do anything since we know in Java that all the instantiations extend this object class Java.langular object class. Therefore this wait notify notify all methods would be implemented. So you don't need to do anything at all. You just need to know that these methods exist. And since this Q is also extending an object class therefore it will also have these methods. And therefore what it will do is this particular Q this particular Q is now saying hey I have to wait I have to wait for a condition to be true. Okay now this wait basically what it does is it throws an interrupted exception. Now what exactly it is we will see that when we read about interrupts. So basically what can happen is you know there's some there is some other thread which can basically interrupt this thread while it is waiting. Right? If that happens when the call returns when this thread is unblocked then this interrupted exception will be catched again this let's not get too much deep into this okay so for now just try to know that okay whenever whenever this condition is true that means there's that you he can't go and remove item from the queue has to wait in think in simple English terms he has to that particular thread has to wait and why it has to wait because if it has to wait then other threads other threads gets a chance to access this particular critical section. So now this thread is waiting it relinquishes the lock so that other threads can access this section right and it is now waiting till the time the queue has some item that it can remove. Okay, how will it know that the que has some items? Someone needs to notify this particular thread that hey I have put some items in the queue. So now please awaken and please start your execution. Okay, who will do that? Whichever thread is trying to add an item, it will do that. Right? So what happens is whenever this particular Q adds an item, it calls Q dot notify all. Notify all means notify all the threads and notify means only notify that particular thread. Okay, here we are calling notify all because we want to notify all the threads that are in the wait state, right? That those who were waiting, all those remover threads who were waiting for the queue to be full. Okay. And we notify all those threads and single notify means notifying a single thread. There are two functions. Okay. So whenever this thread adds some item it notifies the other threads. The threads that were waiting over here they get awakened right. And now they are like kind of ready to execute. I will I will come to the more intricacies that I mean they're not exactly ready for execution straight away. Again that to fight for the locks and all that I will come into detail. But for now just try to think it in think of it in this way that whenever I call the notify all method this added thread calls the notify all method the thread the threads that were waiting are now awakened okay and now they can start execution from here okay whatever lines were written it can start execution from here so whenever it called qwe these threads were blocked in this line and then notify was called and then once they're again pushed into runnable state they can start execution from here okay cool now also So we'll do the same thing for the adder as well because what if the size of the uh there is no items that can be added this capacity is full then it also has to wait the adder set also has to wait. Therefore we will also say Q dot weight and similarly we have to like catch hold of this exception. So we will implement this exception. So now the question is still how long this adder thread will wait right it will wait till some of the items is removed from the queue so that now it has more room to push again right and who will notify the adder thread who will notify the adder thread that hey there is some item now left in the queue because I have removed some item the remover thread will do it so the remover thread when it removes it also calls the notify all method okay so what is ideally happening is whenever whenever an adder thread gets access to the synchronized block it first checks that hey is this can I push items to this queue if it can't then it has to it has to wait and it has to wait for other remover threads to notify it that hey now you can add items to the queue okay then it goes on adds item and once it adds item it also has a responsibility that it has to notify other waiting threads that hey I've add items to the added items to the queue so if you are waiting for some items to be added now please go ahead and start the execution right and then it does whatever it has to there is one slight problem over here okay now let's say there is some added thread comes and it gets access to this Q lock and it starts executing and it checks that for some reason the Q's capacity is full. Therefore, it has to wait. Okay, let's say this added thread is waiting. Okay, and this added thread relinquishes the lock so that other threads can execute. Now, let's say another added thread added two gains access to this lock and it also finds out that hey this Q size is equals to capacity there is no room to insert any more item to this que. So therefore it also is now into a waiting state. And so now inside the waiting state there are two adders threads that are waiting for the turn to add items to the queue. By the way every object has a weight set uh and in that set basically all these threads are maintained which are currently waiting for that particular object. We'll see all of it in action. Now let's say that the next comes some remover thread which basically removes an item from the queue and now there is only one slot. Okay, it removes one item. So there is now one slot left to be added. This remover thread what it does is this notifies all the threads. So it notifies all these two threads that were in the weight set of that object of the lock of the queue. Right? So now there were these two threads that is added one and added two that basically now got kind of unblocked. Right? So now it got notified that hey now you are free to add items to the queue. So now both of them wants to gain the lock again right because now they don't have the lock with them. So now both these two threads are fighting to get the lock. Okay. So now let's say added one get the locks first gets the lock first. So this added one right. So it will start executing after this line right and after this line comes this. So it will add items. It will notify the other threads and it will return true and and it goes out of the critical section. Now next is added to it was also fighting for the lock because it also got unblocked. It also got awakened right uh when the remover thread called the notify all and it was waiting for its turn to execute because first the added one thread got access okay uh now added two will get access okay and it now and it also resumes it execution after this line because it also block got blocked here okay so now it again goes and adds item to the queue but hey there is no space because one item was removed what happened was both these threads got awakened right and adder one one first won the bid to execute this code. After this, it added an item. Then added two got the chance to execute the code. The problem was there was no further room left to add. Okay, so now you might say okay let's add a condition again over here like if q dot size equals to capacity that might solve the problem. But what if there are three threads then again you will add a condition. So the best way of dealing with this is instead of using an if using a while loop both in both places and in in that doing this the problem will be solved. Why? Let's say the adder one, let's say adder one wins the lock. Okay, let's say both the threads are awakened. They're removed from the weight set and they're both trying to acquire the lock again. Remember when the when a particular thread calls a weight method, it relinquishes the lock. It doesn't have the lock with it anymore. And next time when it is awakened, it again has to fight for the lock, right? As it was as the other threads were doing. And when it gets the lock, it now resumes its execution from here, right? And then from after this after this line if there is a while loop it will again go and check back this condition. And this first thread checks okay there is one room left. So I can go and add this item I can notify it and I can return true. Now the added two gets the chance to get the lock and gets a chance to execute after this line. But instead of going directly to this this add item it has since there is a while loop it again has to go and check the condition. And here it checks hey no no no no capacity is there is no room. So again it goes to the weight set and here we help we kind of maintain the consistency or we don't allow more items to be added than the capacity of the queue. So please remember instead of if there's a very common mistake that people do you have to use a while. Okay. So now I think it's a good time since we have talked about wait notify notify all it's a good time to read about the thread states right so when while in college when we were studying about the thread states you're not able to figure out that hey why are we getting taught this theory right what what sense does it make I understand these thread states but what exactly does it signify so now you will exactly be able to relate that what does exactly signifies since I have shown you the practical side of things okay so see when a thread is created right uh so it is in the new state and then it is in the ready to run state once to start the thread, right? And once the thread gets scheduled, it is in the running thread running state. And once the run method gets fully executed, it goes to a dead state, right? And once the thread is dead, you cannot, you know, uh start that thread again. That thread is dead. It's done and dusted. Okay? So now what you can do is let's say it is running. What are the things that can happen? Let's say you call thread. Okay. So when you call thread dots sleeps, it enter into a non-runnable state that is the sleeping state. Right? So there can be multiple non-runnable states. One of them is the sleeping state where the thread is not running. Okay. Now in sleeping state what happens? The thread sleeps for a specified amount of time. So another non-runnable state is a block for iOS which basically the thread is waiting for some user input. Okay. Now one thing to note here that while sleeping the thread does not relinquish any lock. It will still hold a lock. It won't give the lock to someone else or some other thread. Okay. Now there is another state which is blocked for joint completion which I'm going to cover just after this part. So I'm not going too much into depth. So now we just saw this right? So let me just go through this picture once again so that you understand really well. So let's say the trade was running right it was in a running state that it was executing. Now it had to wait for a condition. So when it called the wait method what happened was it entered a non-runnable state which is the waiting for notification state right? Whenever it got notification it got into a blocked for lock acquisition state. Okay. it please note that the thread when whenever it got the notification it didn't directly jump into running uh or it didn't jump into directly the runnable state it it transitioned into the block for lock acquisition state and what is this block for lock acquisition state this block or lock acquisition state is nothing but a thread waiting to acquire a lock that means whenever you have a synchronized block or a synchronized method you're trying to acquire a lock then you are in a block for lock acquisition state so only one of the thread will grab hold of the lock and it will leave the non-runnable state and it will be running it will be in the runnable state and other thread will be in the block for block acquisition state. So that is the block for lock acquisition state and please remember whenever you call the weight method what happens is that in that every object has a weight weight set. So in that weight set those thread will be inserted and on notification those it those threads will remove from the weight set and it will be transitioned into the block for lock acquisition state and one of the threads one of the threads has to compete and win the lock as it was doing previously while it was in the synchronized before entering the synchronized block or the critical section. So please note this whenever a thread is notified when it is awakened right it does not directly jump into the runnable state it has to fight for the lock that is that means it goes to the block for lock acquisition state and only then it can start executing. So these are the different thread states that exist. Now in Java there are some enums right? So the thread class basically provides the get state method to determine the state of the current thread. Uh and the method returns a constant of type thread dot state and these are the enum values that you can see on the screen. you have new runnable blocked waiting time waiting and terminated and you can actually you know see on the right part that what is the description and what does and what exactly does it mean so back to the main class I have pasted a code right which basically will tell you about uh different thread states that exist so this is this is just a small demo uh that I've taken from the internet uh it's a very small and short and nice crisp demo so basically I creating a thread right and it is like first uh like it is sleeping for a while it is sleeping for you know 1 second and then it runs a hot loop. It does nothing and then it uh it comes out of the loop, right? And then I'm starting to run this thread and in the main thread there is this while loop that I'm running infinitely where I'm getting the thread state, right? I'm printing that state and I'm coming breaking out of this while loop when I find that the thread has been terminated. In other words, when the state of the thread is equals to equals to thread state terminated, right? So let's run this code. Okay, you see the main got started then the thread was runnable and then it was sleeping therefore it was time waiting it for 1 second right and then again it transitioned into runnable where the hot loop was running and then finally it got terminated. So you can see these are basically the different thread states and you can use the thread dot state uh class or the enum right and you can basically do uh and you can basically use the uh method of get state to find out the current state of the thread. Now there is another method yield which I want to show you right. So whenever the start method is called in a thread right it is basically uh eligible for running that is it waits for it turn to get CPU time. Okay. Now the thread scheduleuler decides that which thread to run and for how long. So whenever the thread gets scheduled to run by the CPU from the ready to run state it basically transitions into the running state. Okay. Now let's if you call this eel method what happens is we're basically telling this CPU that hey put this thread that was running the current thread that was running back into the ready to run state once again so that it gives other thread a chance to run. Now again please note that it is it is like an advisory method to the JVM which means that there is no guarantee that even if you say that even if you call this eel method this thread will actually transition at that point of time only to the ready to run state like there is absolutely no guarantee it is just an advisory method to the JVM and it is up to the JVM to decide whether it should idly want that particular thread to push it again back to the ready to run state okay then we have the sleep method which we also saw so basically let's say the thread we we basically call the start or meth method of the thread and hence the thread is ready to be run and then the C CPU schedules a particular thread to run and now it is in the runnable state or in the running state and then we call thread dos sleep. Okay. So whenever we call thread dots sleep what happens is it goes to the sleeping state and it can only be awakened in on two conditions. The first condition is the time which we passed as parameter to the sleep function got elapsed. That means you wanted the thread to sleep for let's say 1 minute or one 1 second. That time got elapsed and then the thread will again start executing. it will again directly jump to the ready to run state right and it can start it execution or one another thing that can happen is another some another thread interrupted this current thread in that case it won't wait for the time to elapse it will it will go to the ready to run state right and on when it when gets a chance to run by the CPU that means when it gets to the running state it will throw an interrupted exception that is why that is why we always whenever we are using the whenever we are calling the sleep method we have to enclose it inside an interrupted exception that means we have to catch that exception Because there's a chance that if the if some other thread interrupts that particular thread when it comes out from the sleep method it will throw the interrupt exception. It won't directly throw whenever it gets a chance to execute then it will throw. Same for the uh wait method as well. So let's say when the thread was waiting and some other thread call the interrupt method on that particular thread that was waiting it won't directly throw an exception. It will whenever it gets the chance whenever it comes out right. So whenever that thread gets a chance to run then it will throw an interrupted exception. That's why we were whenever we calling this v method we were enclosing it with an interrupted exception right within a try catch block basically. So if some other thread called interrupt method right whenever this thread got a chance to run after this it has completed its weight then it will run into an interrupt exception. Similarly we also saw for the waiting and notifying. So let's say a thread was running then it was asked to wait. So it is now waiting for the notification and whenever some other object call the notify on this thread or notify all method it goes to the block for acquisition state it doesn't directly go to the ready to run state and when one of this thread acquires the lock then only it goes to the ready to run state okay and also please note that whenever the thread is sleeping it doesn't relinquishes any lock it doesn't lets go of any lock but whenever it is waiting for a notification it lets go of a lock that's the difference and also also it only relinquishes the lock of the object on which the wait method was invoked. It does not relinquish any other object loss that it might hold and it will remain locked while the thread is waiting. Okay. And each object as I said has a weight set containing threads waiting for notification. Threads in the waiting for notification state are grouped according to the object whose weight method they invoked. Okay. So again just to summarize let's say there is a thread one who acquires a lock right and now it finds that there is some condition that is not fulfilled. So it calls the weight method. some other thread comes in and acquires this lock because this thread T1 has already relinquished that lock and this thread 2 now executes completes its task calls the notify method and then the lock it releases the lock please note that the when when it calls the notify method it doesn't release the lock immediately there is some time gap right so it calls the notify method then the thread other thread is notified and after a certain point of time that lock is released by thread 2 and now this thread T1 it was it is now transition from the way state to the block for lock acquisition state it doesn't directly go to the runnable state that hey I have been notified so I will now start executing no it doesn't happen because it has to fight with other threads as well because other threads might be in the way it said right so there can be multiple other threads waiting with him as well so that is why like none of the threads uh directly starts executing right they goes into the block for lock acquisition state where it has to fight for the lock and whichever thread acquires the lock the lock acid then it start executing right a couple of things a thread in the wait for notification state can be awakened by occurrence of one of these Three incidents for sleep. It was two incidents, right? One either the time elapses or the second was it was interrupted. Here there are three incidents. One is another thread invokes the notify method on the object of the waiting thread and the waiting thread is selected to be awakened. Right? Second is the waiting thread times out. We can also pass some time to the wait function. Right? So here there's an overloaded method where inside the wait method we can pass some time as well. Okay. And third is another thread interrupts the waiting thread. So if some other thread interrupts the thread that was waiting, it will transition to the block for lock acquisition state and once once it gets a chance to run again, then it will throw an interrupted exception. Okay. So what happens when a thread is notified? So invoking the notify method on object wakes up a single thread that is waiting for the lock of that object. Right? And the selection of a thread to awaken is dependent on the thread policies implemented by the JVM. We don't have any hand on it. So don't make any assumptions. on be notified a waiting thread first transits to the block for lock acquisition state which I've been telling for so long to acquire the lock on the object first and not directly to the ready to run state and last is the thread is also removed from the weight set of the object now let's look at the important methods for wait and notify so as I told you that you can like give some time you can pass some parameters to the wait methods and also you can you can choose not to pass any time and then there are this notify and notify all methods so whenever you call this weight method the thread is added to the weight set of the current object Right? So now let's look at this timed out concept. So let's say that when whenever we call the wait method by passing some time, it means that the thread should wait before being timed out. Okay? If it was not being awakened on being notified. So let's say some other thread didn't notify that particular thread. So it won't wait indefinitely for that. If you pass some time, it would wait maximum till that time. Okay. Now the awaken thread completes in the usual manner to execute again. like it will basically pass into the block for lock acquisition state get the lock and will start executing again after the wait uh method. But one thing the awaken thread has no way of knowing whether it was timed out or woken up by one of the notification states. If you are passing the uh time as a parameter but however if some other thread were interrupting that particular thread on which the wait method was called then it will catch an interrupted exception. Okay, then you would get to know hey this thread was interrupted. But if the thread was timed out and by timed out I mean that you passed up time as a parameter to the wait method in that case you don't know whether the thread was awakened or being notified or that time elapsed right that because there won't be any exception being thrown when the thread against resumes execution after the wait method okay so that is one thing you have to note another is interrupted which I just told you that another thread invoked the interrupt method on the waiting thread the awaken thread is enabled but the return from the wait call will now result in an interrupted exception if and when the awakened thread finally gets a chance to run. Okay. And the code invoking the wait method should be prepared to handle this check exception which we were already doing. The difference between timed out and interrupted is in interrupted you get to know that this thread was interrupted by some other thread but in timed out here you don't know whether it got timed out or it got uh or it got notified right because there is no exception being thrown. It's just the time that you passed it got either that got elapsed or there were some other threads notified that and it got awakened. Right? Okay. So now let's look at another important concept that is the thread dot join. That is the joining concept the joining of threads. Let's see what happens. There's nothing much fancy with it. So, back to the main class. We'll comment out this code. We will create a thread. Thread thread equals to new thread. Okay. We'll have something. We'll pass the runnable and we will do this out uh thread dot current thread right and we will pass some name our thread. Now we will start and here we will write main is exiting. Okay. So in this case this start will since it's an asynchronous call it will return immediately and now this thread that is our thread will have its own parallel way of executing and this main thread will have its own parallel way of executing. Okay. But what if I want to stop this asynchronous thing and I want this thread, right? I want this thread to first complete the the thread that I just created to first complete. Okay, and then my main thread to run. In that case, I use this method that is thread dot join. Okay, I can also give a time to it. And if you just go and check the join method, so you can see you can also give some time to it, right? And that time would mean that I would tell you what does the time mean. But first it's a check exception that we have to handle. So let's handle this exception. So it basically you have to surround it with a try catch. It it basically throws an interrupted exception. Okay. So what ideally happens is whenever you call this thread dot join what happens IDE is it will wait for this method or this run method of that particular thread on which you call the join method to complete first and then your program will start executing. that ID blocks the main method to stop executing parallelly. Right? So whenever you call this thread dojo join, what happens is all the threads, all it child threads will complete first and then the program execution flow will continue with this part. Right? So let's run this code and you see main is starting then this thread got executed and then the main is exiting. Right? So basically you blocked the main thread from executing further because now when you call this thread dojo you're saying hey this thread must complete its actions first and then only the main thread will continue. So what if if I didn't do this and save it. Let's run this. You see the main started the main exited and then this thread got parallel executed. So now this is a parallel execution here. We didn't block our main thread and the main thread was first allowed to complete and then this thread got executed. But if we did this join in that case what happens is the main thread is blocked. it won't be allowed to like execute further and it will basically now be converted into a sequential execution like basically it is now saying that okay you first complete all of your task all of your child hits and then only we will continue from here that's basically join and you are seeing some overloaded methods right where we can pass some time as well so that means either you complete but or if the time that we are passing has elapsed then like the main will continue so basically either so it is very similar to the weight right either that condition will be true if the time that we are passing is has been elapsed then uh like I will not wait anymore. Similarly for this joint the same thing right if you are passing any time it will be like okay either you complete or if it has not completed by the time that I have passed this parameter then it will come back and then the main will execute. Okay now let's look at this picture. So basically there is ready to run right and the thread got scheduled and it was running when we call the join method on that particular thread. Now this particular thread is blocked for join completion and there can be three ways where it can return to the ready to run state again. one the join is completed or the time that he passed as parameter as elapsed or the thread got interrupted by some other threads and that is the reason we are catching the interrupted exception in case the thread got interrupted by some other threads it when it when it gets a chance to run it will th interrupted exception and that is why we're catching that exception so this was all about thread joining now we will look into two important concepts of threads that is thread priorities so basically threads are assigned priorities that the thread scheduleuler can use to determine how the threads will scheduled, right? The thread scheduleuler can use thread priorities to determine which thread gets a chance to run. So if you go to the thread class, you will see that it has a variable called priority which is initially set to five and that five is basically as is defined by a constant that is thread do nom priority and the max priority that you can assign is 10 that is a thread domax priority and the lowest priority is thread dominity. So if you go back to the code there is this method uh let's say if I want to assign let's say if you want to get the priority so that is get priority in this way you can get the priority and if I just want to print the uh priority you will see that it will give me non priority okay so let me just print this out so it prints five right uh this is the default also we can set the priority of the thread right by setting the priority to one or any value between 1 to 10 okay so we have this get priority set priority methods And the thread generates the priority of its parent thread. Uh and also the set priority is an advisory method. Okay, meaning that it provides a hit from the program to the JVM. But JVM is in no way obliged to honor your advice. Okay, and what do we do with thread priority? So basically the thread scheduleuler favors giving CPU time to the thread with the highest priority in the ready to run state, right? But there is no guarantee. It favors but there is no guarantee that it will. Hence heavy reliance on thread priorities for the behavior of a program can make the program unportable across platforms as thread scheduling algorithms is host platform dependency. So basically you can set priorities to a thread but like the JVM would follow it. There is no such guarantee. Okay. Then we come to thread scheduling. So scheduulers and JVM implementations usually employ one of the two following strategies. One is the preemptive scheduling. So what is that? If a thread with a higher priority than a current running thread moves to the ready to run state, the current running thread can be moved to the ready to run state to let the higher priority thread execute. Right? Again, it depends on the platform. But yeah, if you if the thread has a higher priority and if the JVM follows preemptive scheduling, then the thread with the higher priority would be given an advantage to be pushed to the runnable state. And then another is the time slice or round drop in scheduling. There the running thread is allowed to run for a fixed length of time after which it moves to the ready to run stateing for it to run again. Right? We can also use the e method if you want to send a currently executing thread back to the ready to run state. We have already seen that in action. Also the JVM itself also does that. Right? I mean uh by using the time slice or the round robin schedule. Again I emphasizing this that the thread scheduulers are implementation and platform dependent. Therefore, how threads will be scheduled is very very unpredictable from platform to platform. Okay, we are almost at the end of the video. Before ending this video, there is one very important question and one very important topic that I would like to cover that I was asked in RCM and also in one of the interviews in Goldman Sachs that is about deadlocks. So, first I would introduce you the concept of deadlocks which I've already read in operating system and then I would talk about and discuss the solution of the question which I got asked. So, I mean this this I understand it's a very long video and you might have a lot of things to grasp. So do feel free to watch this video again and again and create some notes and if you can create some notes do write it down in the comment section or like give the link right and I would be more than happy to pin it and thank you so much for watching this video till here. Uh it takes a lot of effort to create this type of tutorial content because it it's not only about knowing these things but how to cater these things to you guys so that you can understand these things. It's something that takes a lot of toll for us creators. So yeah please motivate us by you know liking this video, pressing the subscribe button and uh pressing the bell icon. So every time I upload such a new video uh you guys are notified and also do let me know that what is the next topic on Java that you want me to make a video on. It can be oops it can be generics uh it can be lambda expressions streams API whatever whatever topic that you wish me to make a video on and I would be more than happy to make a similar concise video or if you want an advanced video on multi- threading itself. Okay. So now with that let's not waste any further time and let's look at the last section of the video that is deadlocks. So basically it's a paradoxical situation where this thread has a lock and requires the lock of this thread but this thread cannot relinquishes the lock because it needs a lock which this thread holds right. So basically since each thread is waiting for the other thread to relinquish a lock they both remain waiting for each other in the blocked for lock acquisition states and the threads are set to be deadlocked. Okay. So now the question that I was asked that create a program in Java where basically create a deadlock situation. So let's say there's a thread T1 which has acquired a lock okay on an object and there is a thread T2 which has acquired another lock right which is called O2. Now thread T1 is now waiting to acquire the lock on O2 but it cannot because it the lock is with T2 right and at the same time T2 wants to acquire the lock O1. Okay but it cannot because this lock is is with T1 and now they are in a paradoxical situation or in a deadlock situation. Okay, now let's jump into the code and see how can we actually create a deadlock situation. So let's create two lock objects. Okay, because here we need at least two lock objects to create a deadlock situation. So let's call this lock one and let's call it okay and let's create this log two and let's call it duta. So now now let's create a thread thread one new thread. Okay, where we pass a runnable object. First we will pass the name thread one. Okay, and thread two equals to new thread. We'll pass the runnable object and the thread two. Okay, now let's pass this runnable object. First, we want to introduce a synchronized block ensuring that it is a critical section. It needs a lock. Okay. Um and let's have this lock one object. Okay. And let us make it sleep for a while. Okay. And after that, let's say it needs another lock. It might happen to access a critical section, you might require more than one lock, right? It is very much possible. Okay. So now, let's say it it will require this lock as well to gain access to this critical se section. And here we will say okay lock acquired. Okay. Now pass the runnable for this. So here what we'll do is we will reverse the lock order right which actually this is basically if you want to create a deadlock you reverse the lock order right in which uh you want the two threads to acquire. So basically what we will do is we will first try this thread will first try to acquire the lock two and this thread will first try to acquire the lock one. Okay. And basically I will copy this piece of code. And I will change this to lock one. And I will just uh this since it's an checked exception so I have to uh enclose it with try catch. Yeah. And similarly here as well. Let me copy this piece of code and let you paste it here. Okay. So what I'm doing is I am ensuring that okay this thread if it gets access to the critical section it will have this lock one and by this time this thread has lock two. Now this thread will now try to fight for lock two but this lock two is with this thread and it cannot relinquish because it is trying to fight for lock one which is with this thread. So that creates a deadlock situation right. So if you run this piece of code okay uh so if you run thread one start and if you do thread 2 start you would see that this program would never end up doing anything. The main is starting and that's it. Nothing else will happen. Just wait, wait, wait, wait indefinitely and the program will never terminate because the program has now gone into a deadlock situation where uh basically both of these trades are now in the block for lock acquisition state. Right? So always ensure that the order in which these all of these threads will acquire the lock should always be the same. So if we if you want to get rid of this deadlock situation, we have to make ensure that the order in which all of these threads acquire the lock is the same. So now if you do this you will see that we got rid of the deadlock situation and both the side got acquired the lock and executed right. So if you want if the interviewer asks you to create a deadlock situation this is a sample piece of code which you can write. So what you just have to do is you have to just like reverse reverse the order that's it just have to reverse the order of the lock that you want that the thread each of the threads wants to acquire. So if this wants to acquire lock one first this should acquire log two first and then it will acquire the lock two and then it will acquire the lock one. Okay, so this is about how you can create a deadlock. But in general, the cause of a deadlock is not really easy to discover. But for the purpose of interview, I would say uh that just know what is a deadlock and also know how can you create a deadlock which I just shown. So that brings an end to the multi-threading uh video. I think I've covered all the important concepts that that would be required for you during your semesters. I've also covered some of the important concepts for operating systems as well like deadlocks. Okay. Uh also it will be really really helpful for your placement interviews. uh also it will really helpful while you will be working for your companies. It will also helpful for if you are trying to prepare for SD2 interviews or low-level design or machine coding rounds because multi-threading really plays a good role over there as well. Thank you so much if you watched this video so far. Don't forget to press the like button. Don't forget to comment down below the favorite part of the video or what is the new thing that you learned in this video. Uh don't forget to share it on social media on LinkedIn and Twitter tagging me that would mean the world to me. Don't forget to subscribe to my channel. and press the bell icon so that every time I upload a new video you get notified and also don't forget to mention below that is the next topic that you want to make me a video on and I will be more than happy to make a video on the same very similar to this in a more concise manner. Also don't forget to check out my company review playlist. Don't forget to check out my low-level design playlist. Lots of other DSA resources, lots of content, software engineering content that I put on my channel. So yeah, do consider checking out my channel if you're new to it. Having said that, I will bid at you over here. Take care and I will see you in some other tutorial